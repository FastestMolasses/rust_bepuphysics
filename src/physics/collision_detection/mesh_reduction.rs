// Translated from BepuPhysics/CollisionDetection/MeshReduction.cs

use crate::physics::collidables::triangle::Triangle as CollidableTriangle;
use crate::physics::collidables::triangle::TriangleWide;

/// Re-export Triangle for backward compatibility.
pub type Triangle = CollidableTriangle;
use crate::physics::collision_detection::collision_batcher_continuations::{
    ICollisionTestContinuation, PairContinuation,
};
use crate::physics::collision_detection::contact_manifold::{
    ConvexContact, ConvexContactManifold,
};
use crate::physics::collision_detection::nonconvex_reduction::{
    FlushResult, NonconvexReduction, NonconvexReductionChild,
};
use crate::utilities::math_helper;
use crate::utilities::matrix3x3::Matrix3x3;
use crate::utilities::memory::buffer::Buffer;
use crate::utilities::memory::buffer_pool::BufferPool;
use glam::{Quat, Vec3, Vec4};

/// Flag used to mark a contact as being generated by the face of a triangle in its feature id.
pub const FACE_COLLISION_FLAG: i32 = 32768;
/// Minimum dot product between a triangle face and the contact normal for a face collision.
pub const MINIMUM_DOT_FOR_FACE_COLLISION: f32 = 0.999999;

/// A bounding box for mesh reduction queries.
#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct BoundingBox {
    pub min: Vec3,
    pub max: Vec3,
}

/// SOA-ified triangle data for per-contact testing in mesh reduction.
#[repr(C)]
#[derive(Clone, Copy)]
struct TestTriangle {
    /// SOA-ified anchor positions (x: face anchor, y: edge AB anchor, z: edge BC anchor, w: edge CA anchor).
    anchor_x: Vec4,
    anchor_y: Vec4,
    anchor_z: Vec4,
    /// SOA-ified normals (x: face normal, y: AB edge normal, z: BC edge normal, w: CA edge normal).
    nx: Vec4,
    ny: Vec4,
    nz: Vec4,
    distance_threshold: f32,
    child_index: i32,
    /// True if the manifold associated with this triangle has been blocked.
    blocked: bool,
    /// True if the triangle did not act as a blocker and can be removed if blocked.
    force_deletion_on_block: bool,
    /// Normal of a triangle detected as infringing, in mesh space.
    corrected_normal: Vec3,
}

impl TestTriangle {
    #[inline(always)]
    fn new(triangle: &CollidableTriangle, source_child_index: i32) -> Self {
        let ab = triangle.b - triangle.a;
        let bc = triangle.c - triangle.b;
        let ca = triangle.a - triangle.c;
        let distance_threshold = 1e-3
            * math_helper::max(
                triangle.a.length_squared() * 1e-4,
                math_helper::max(ab.length_squared(), ca.length_squared()),
            )
            .sqrt();
        let n = ab.cross(ca);
        // Edge normals point outward.
        let edge_normal_ab = n.cross(ab);
        let edge_normal_bc = n.cross(bc);
        let edge_normal_ca = n.cross(ca);

        let nx = Vec4::new(n.x, edge_normal_ab.x, edge_normal_bc.x, edge_normal_ca.x);
        let ny = Vec4::new(n.y, edge_normal_ab.y, edge_normal_bc.y, edge_normal_ca.y);
        let nz = Vec4::new(n.z, edge_normal_ab.z, edge_normal_bc.z, edge_normal_ca.z);
        let normal_length_squared = nx * nx + ny * ny + nz * nz;
        let inverse_length = Vec4::ONE / Vec4::new(
            normal_length_squared.x.max(1e-30).sqrt(),
            normal_length_squared.y.max(1e-30).sqrt(),
            normal_length_squared.z.max(1e-30).sqrt(),
            normal_length_squared.w.max(1e-30).sqrt(),
        );
        let nx = nx * inverse_length;
        let ny = ny * inverse_length;
        let nz = nz * inverse_length;
        let anchor_x = Vec4::new(triangle.a.x, triangle.a.x, triangle.b.x, triangle.c.x);
        let anchor_y = Vec4::new(triangle.a.y, triangle.a.y, triangle.b.y, triangle.c.y);
        let anchor_z = Vec4::new(triangle.a.z, triangle.a.z, triangle.b.z, triangle.c.z);

        TestTriangle {
            anchor_x,
            anchor_y,
            anchor_z,
            nx,
            ny,
            nz,
            distance_threshold,
            child_index: source_child_index,
            blocked: false,
            force_deletion_on_block: true,
            corrected_normal: Vec3::ZERO,
        }
    }
}

/// Performs mesh boundary smoothing and contact reduction for mesh-convex collisions.
#[repr(C)]
pub struct MeshReduction {
    pub triangles: Buffer<CollidableTriangle>,
    /// Whether the pair was flipped (mesh is considered shape B).
    pub requires_flip: bool,
    /// Orientation of the mesh used to transform contacts into mesh local space.
    pub mesh_orientation: Quat,
    pub query_bounds: BoundingBox,
    /// Nested nonconvex reduction that handles the final manifold assembly.
    pub inner: NonconvexReduction,
    /// Pointer to the mesh (opaque).
    pub mesh: *mut u8,
}

impl ICollisionTestContinuation for MeshReduction {
    fn create(&mut self, child_manifold_count: i32, pool: &mut BufferPool) {
        self.inner.create(child_manifold_count, pool);
    }
}

impl Default for MeshReduction {
    fn default() -> Self {
        Self {
            triangles: Buffer::default(),
            requires_flip: false,
            mesh_orientation: Quat::IDENTITY,
            query_bounds: BoundingBox::default(),
            inner: NonconvexReduction::default(),
            mesh: std::ptr::null_mut(),
        }
    }
}

impl Copy for MeshReduction {}
impl Clone for MeshReduction {
    fn clone(&self) -> Self {
        *self
    }
}

/// Computes a mesh-space contact and normal from a convex contact manifold.
#[inline(always)]
unsafe fn compute_mesh_space_contact(
    manifold: &ConvexContactManifold,
    inverse_mesh_orientation: &Matrix3x3,
    requires_flip: bool,
    mesh_space_contact: &mut Vec3,
    mesh_space_normal: &mut Vec3,
) {
    // Select the deepest contact out of the manifold.
    let mut deepest_index = 0i32;
    let mut deepest_depth = manifold.contact0.depth;
    for j in 1..manifold.count {
        let depth = (*(&manifold.contact0 as *const ConvexContact).add(j as usize)).depth;
        if deepest_depth < depth {
            deepest_depth = depth;
            deepest_index = j;
        }
    }
    if requires_flip {
        // Mesh and triangles are shape B — flip before transforming.
        let contact_offset =
            (*(&manifold.contact0 as *const ConvexContact).add(deepest_index as usize)).offset
                - manifold.offset_b;
        Matrix3x3::transform(&contact_offset, inverse_mesh_orientation, mesh_space_contact);
        Matrix3x3::transform(&(-manifold.normal), inverse_mesh_orientation, mesh_space_normal);
    } else {
        let contact_offset =
            (*(&manifold.contact0 as *const ConvexContact).add(deepest_index as usize)).offset;
        Matrix3x3::transform(&contact_offset, inverse_mesh_orientation, mesh_space_contact);
        Matrix3x3::transform(&manifold.normal, inverse_mesh_orientation, mesh_space_normal);
    }
}

/// Tests whether a contact normal should be blocked by a neighboring triangle.
#[inline(always)]
fn should_block_normal(
    triangle: &TestTriangle,
    mesh_space_contact: Vec3,
    mesh_space_normal: Vec3,
) -> bool {
    let px = Vec4::splat(mesh_space_contact.x);
    let py = Vec4::splat(mesh_space_contact.y);
    let pz = Vec4::splat(mesh_space_contact.z);
    let offset_x = px - triangle.anchor_x;
    let offset_y = py - triangle.anchor_y;
    let offset_z = pz - triangle.anchor_z;
    let distance_along_normal =
        offset_x * triangle.nx + offset_y * triangle.ny + offset_z * triangle.nz;

    if distance_along_normal.x.abs() <= triangle.distance_threshold
        && distance_along_normal.y <= triangle.distance_threshold
        && distance_along_normal.z <= triangle.distance_threshold
        && distance_along_normal.w <= triangle.distance_threshold
    {
        // Contact is near the triangle. Check if normal infringes on triangle's face region.
        let negative_threshold = triangle.distance_threshold * -1e-2;
        let on_ab = distance_along_normal.y >= negative_threshold;
        let on_bc = distance_along_normal.z >= negative_threshold;
        let on_ca = distance_along_normal.w >= negative_threshold;
        let normal_dot = triangle.nx * mesh_space_normal.x
            + triangle.ny * mesh_space_normal.y
            + triangle.nz * mesh_space_normal.z;
        // If the normal points in any direction not on the triangle's solid side, it can't be infringing.
        if normal_dot.x > -TriangleWide::BACKFACE_NORMAL_DOT_REJECTION_THRESHOLD {
            return false;
        }
        if !on_ab && !on_bc && !on_ca {
            // Contact is within the triangle.
            return true;
        } else {
            // Contact is on the border. Is the normal pointing outward on any edge the contact is on?
            const INFRINGEMENT_EPSILON: f32 = 1e-6;
            if (on_ab && normal_dot.y > INFRINGEMENT_EPSILON)
                || (on_bc && normal_dot.z > INFRINGEMENT_EPSILON)
                || (on_ca && normal_dot.w > INFRINGEMENT_EPSILON)
            {
                const SECONDARY_INFRINGEMENT_EPSILON: f32 = -1e-2;
                // At least one edge is infringed. Are all contact-touched edges nearly infringed?
                if (!on_ab || normal_dot.y > SECONDARY_INFRINGEMENT_EPSILON)
                    && (!on_bc || normal_dot.z > SECONDARY_INFRINGEMENT_EPSILON)
                    && (!on_ca || normal_dot.w > SECONDARY_INFRINGEMENT_EPSILON)
                {
                    return true;
                }
            }
        }
    }
    false
}

/// Applies blocking result to a triangle's manifold.
#[inline(always)]
unsafe fn try_apply_block_to_triangle(
    triangle: &TestTriangle,
    children: &mut Buffer<NonconvexReductionChild>,
    mesh_orientation: &Matrix3x3,
    requires_flip: bool,
) {
    if triangle.blocked {
        let manifold = &mut (*children.get_mut(triangle.child_index)).manifold;
        if triangle.force_deletion_on_block {
            // No other manifold infringed upon this one — safe to just zero its contacts.
            manifold.count = 0;
        } else {
            let mut manifold_has_positive_depth = false;
            for j in 0..manifold.count {
                if (*(&manifold.contact0 as *const ConvexContact).add(j as usize)).depth > 0.0 {
                    manifold_has_positive_depth = true;
                    break;
                }
            }
            if manifold_has_positive_depth {
                // Mutually infringing — correct the normal instead of deleting.
                let corrected = if requires_flip {
                    triangle.corrected_normal
                } else {
                    -triangle.corrected_normal
                };
                Matrix3x3::transform(&corrected, mesh_orientation, &mut manifold.normal);
            } else {
                // No positive depth — just get rid of it.
                manifold.count = 0;
            }
        }
    }
}

impl MeshReduction {
    /// Records a completed child manifold.
    #[inline(always)]
    pub unsafe fn on_child_completed(
        &mut self,
        report: &PairContinuation,
        manifold: &ConvexContactManifold,
    ) {
        self.inner.on_child_completed(report, manifold);
    }

    /// Records an untested child as having zero contacts.
    #[inline(always)]
    pub unsafe fn on_untested_child_completed(&mut self, report: &PairContinuation) {
        self.inner.on_untested_child_completed(report);
    }

    /// Reduces manifolds by performing boundary smoothing on mesh contacts.
    /// This prevents ghost collisions at triangle seams.
    pub unsafe fn reduce_manifolds(
        continuation_triangles: &Buffer<CollidableTriangle>,
        continuation_children: &mut Buffer<NonconvexReductionChild>,
        start: i32,
        count: i32,
        requires_flip: bool,
        _query_bounds: &BoundingBox,
        mesh_orientation: &Matrix3x3,
        mesh_inverse_orientation: &Matrix3x3,
        _mesh: *mut u8,
        _pool: &mut BufferPool,
    ) {
        // A contact is a candidate for correction if:
        // 1) Not a face collision, and
        // 2) Contact position is touching another triangle, and
        // 3) Contact normal infringes on neighbor's face voronoi region.

        if count > 1024 {
            return;
        }

        // Narrow the region of interest (slice).
        let triangles_ptr = continuation_triangles.as_ptr().add(start as usize);
        let children_ptr = continuation_children.as_mut_ptr().add(start as usize);

        const BRUTE_FORCE_THRESHOLD: i32 = 128;
        if count < BRUTE_FORCE_THRESHOLD {
            let mut active_triangles = Vec::<TestTriangle>::with_capacity(count as usize);
            active_triangles.set_len(count as usize);
            for i in 0..count {
                active_triangles[i as usize] =
                    TestTriangle::new(&*triangles_ptr.add(i as usize), i);
            }

            for i in 0..count {
                let source_child = &mut *children_ptr.add(i as usize);
                let face_flag_unset =
                    (source_child.manifold.contact0.feature_id & FACE_COLLISION_FLAG) == 0;
                if face_flag_unset && source_child.manifold.count > 0 {
                    let mut mesh_space_contact = Vec3::ZERO;
                    let mut mesh_space_normal = Vec3::ZERO;
                    compute_mesh_space_contact(
                        &source_child.manifold,
                        mesh_inverse_orientation,
                        requires_flip,
                        &mut mesh_space_contact,
                        &mut mesh_space_normal,
                    );

                    for j in 0..count {
                        let target_triangle = &active_triangles[j as usize];
                        if should_block_normal(target_triangle, mesh_space_contact, mesh_space_normal) {
                            let corrected_normal = Vec3::new(
                                target_triangle.nx.x,
                                target_triangle.ny.x,
                                target_triangle.nz.x,
                            );
                            let target_child_index = target_triangle.child_index;

                            let source_triangle = &mut active_triangles[i as usize];
                            source_triangle.blocked = true;
                            source_triangle.corrected_normal = corrected_normal;
                            let correct_instead_of_delete = !source_triangle.force_deletion_on_block
                                || (*children_ptr.add(target_child_index as usize))
                                    .manifold
                                    .count
                                    == 0;
                            source_triangle.force_deletion_on_block = !correct_instead_of_delete;
                            active_triangles[j as usize].force_deletion_on_block = false;
                            break;
                        }
                    }
                } else if !face_flag_unset {
                    // Clear face flags.
                    for k in 0..source_child.manifold.count {
                        let contact = &mut *(&mut source_child.manifold.contact0
                            as *mut ConvexContact)
                            .add(k as usize);
                        contact.feature_id &= !FACE_COLLISION_FLAG;
                    }
                }
            }

            // Apply blocking results.
            let mut children_buf = Buffer::new(children_ptr, count, -1);
            for i in 0..count {
                try_apply_block_to_triangle(
                    &active_triangles[i as usize],
                    &mut children_buf,
                    mesh_orientation,
                    requires_flip,
                );
            }
        }
        // Note: The tree-query branch (count >= BRUTE_FORCE_THRESHOLD) is omitted here.
        // It requires wiring up Tree.get_overlaps and Mesh.get_local_child which
        // are not yet available. The brute-force path handles the common case.
    }

    /// Tries to flush the mesh reduction if all children are completed.
    pub unsafe fn try_flush(
        &mut self,
        pair_id: i32,
        pool: &mut BufferPool,
    ) -> Option<FlushResult> {
        debug_assert!(self.inner.child_count > 0);
        if self.inner.completed_child_count == self.inner.child_count {
            let mut mesh_orientation = Matrix3x3::default();
            Matrix3x3::create_from_quaternion(&self.mesh_orientation, &mut mesh_orientation);
            let mut mesh_inverse_orientation = Matrix3x3::default();
            Matrix3x3::transpose_ref(&mesh_orientation, &mut mesh_inverse_orientation);

            Self::reduce_manifolds(
                &self.triangles,
                &mut self.inner.children,
                0,
                self.inner.child_count,
                self.requires_flip,
                &self.query_bounds,
                &mesh_orientation,
                &mesh_inverse_orientation,
                self.mesh,
                pool,
            );

            // Return the triangle buffer now that boundary smoothing is done.
            pool.return_buffer(&mut self.triangles);
            // Now flush the inner nonconvex reduction to produce the final manifold.
            return Some(self.inner.flush(pair_id, pool));
        }
        None
    }
}
