// Translated from BepuPhysics/CollisionDetection/WorkerPairCache.cs

use super::pair_cache::{CollidablePair, ConstraintCache};
use crate::utilities::collections::quicklist::QuickList;
use crate::utilities::memory::buffer_pool::BufferPool;

/// A pending add to the pair cache.
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct PendingAdd {
    pub pair: CollidablePair,
    pub cache: ConstraintCache,
}

/// Contains the pending pair cache changes created by a single worker during the last execution of narrow phase pair processing.
pub struct WorkerPendingPairChanges {
    /// The set of pair-pointer associations created by this worker that should be added to the pair mapping.
    pub pending_adds: QuickList<PendingAdd>,
    /// The set of pairs to remove from the pair cache generated by the worker.
    pub pending_removes: QuickList<CollidablePair>,
}

impl Default for WorkerPendingPairChanges {
    fn default() -> Self {
        Self {
            pending_adds: QuickList::default(),
            pending_removes: QuickList::default(),
        }
    }
}

impl WorkerPendingPairChanges {
    /// Creates a new worker pending pair changes.
    pub fn new(pool: &mut BufferPool, pending_capacity: i32) -> Self {
        Self {
            pending_adds: QuickList::with_capacity(pending_capacity, pool),
            pending_removes: QuickList::with_capacity(pending_capacity, pool),
        }
    }

    /// Adds a new pair to the pending adds. Returns the index of the added entry.
    #[inline(always)]
    pub fn add(
        &mut self,
        pool: &mut BufferPool,
        pair: CollidablePair,
        cache: &ConstraintCache,
    ) -> i32 {
        let index = self.pending_adds.count;
        let pending_add = self.pending_adds.allocate(pool);
        pending_add.pair = pair;
        pending_add.cache = *cache;
        index
    }

    /// Disposes the pending changes.
    pub fn dispose(&mut self, pool: &mut BufferPool) {
        self.pending_adds.dispose(pool);
        self.pending_removes.dispose(pool);
    }
}
